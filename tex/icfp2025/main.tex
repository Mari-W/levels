\documentclass[manuscript,screen,review,anonymous]{acmart}
\usepackage[capitalize,noabbrev]{cleveref}
%%
\usepackage{agda}

%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    Bib\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmlicensed}
\copyrightyear{2018}
\acmYear{2018}
\acmDOI{XXXXXXX.XXXXXXX}
%% These commands are for a PROCEEDINGS abstract or paper.
\acmConference[Conference acronym 'XX]{Make sure to enter the correct
  conference title from your rights confirmation email}{June 03--05,
  2018}{Woodstock, NY}
%%
%%  Uncomment \acmBooktitle if the title of the proceedings is different
%%  from ``Proceedings of ...''!
%%
%%\acmBooktitle{Woodstock '18: ACM Symposium on Neural Gaze Detection,
%%  June 03--05, 2018, Woodstock, NY}
\acmISBN{978-1-4503-XXXX-X/2018/06}


%%
%% For managing citations, it is recommended to use bibliography
%% files in BibTeX format.
%%
%% You can then either use BibTeX with the ACM-Reference-Format style,
%% or BibLaTeX with the acmnumeric or acmauthoryear sytles, that include
%% support for advanced citation of software artefact from the
%% biblatex-software package, also separately available on CTAN.
%%
%% Look at the sample-*-biblatex.tex files for templates showcasing
%% the biblatex styles.
%%

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}

\input{agda-generated}
\input{agdamacros}
\input{unicodeletters}

\newtheorem{remark}{Remark}

%%
%% end of the preamble, start of the body of the document source.
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{There is Life in the Universes Beyond $\omega$}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Marius Weidner}
\email{weidner@cs.uni-freiburg.de}
\orcid{0009-0008-1152-165X}

\author{Peter Thiemann}
\email{thiemann@acm.org}
\orcid{0000-0002-9000-1239}

\author{Hannes Saffrich}
\email{saffrich@cs.uni-freiburg.de}
\affiliation{%
  \institution{University of Freiburg}
  % \city{Hekla}
  \country{Germany}}
\orcid{0009-0004-7014-754X}


%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
  The first draft of Martin-L\"{o}f's type theory proposed the
  assumption Type:Type. Subsequently, universe hierarchies have been
  introduced to avoid the resulting inconsistencies. 
  Proof assistants based on type theory support such universe hierarchies
  to varying degree, but they impose restrictions that can make coding
  awkward.

  Specifically, we consider the ramifications of Agda's
  approach to handling levels using a denotational semantics of a
  stratified version of System F as a motivating example.
  We propose a simple fix that extends Agda's capabilities for handling
  universe levels parametrically up to $\varepsilon_0$.
\end{abstract}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
% \begin{CCSXML}
% \end{CCSXML}

% \ccsdesc[500]{Do Not Use This Code~Generate the Correct Terms for Your Paper}
% \ccsdesc[300]{Do Not Use This Code~Generate the Correct Terms for Your Paper}
% \ccsdesc{Do Not Use This Code~Generate the Correct Terms for Your Paper}
% \ccsdesc[100]{Do Not Use This Code~Generate the Correct Terms for Your Paper}

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{Dependent types, universe hierarchies, ordinals, Agda}


%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

\section{Introduction}
\label{sec:introduction}

In type theory, universe hierarchies originate from the need to avoid
logical inconsistencies to maintain good mathematical reasoning.
Martin-Löf's original proposal \cite{martin-lof71:_theor_types} contained the axiom
Type:Type. Subsequently, Girard constructed a paradox (a term
inhabiting the empty type) which proved the
original proposal inconsistent. 
Somewhat ironically, one motivation for type theory was to avoid
Russell's paradox in set theory that results from admitting
unrestricted comprehension. 

\citet{DBLP:books/daglib/0000395} introduced universes in intuitionistic type theory to
handle large collections of types consistently. A universe is a type
that contains other types as elements. Instead of having a single
classifier Type, he defined a hierarchy: 
\begin{itemize}
\item Type$_0$ contains types like numbers, booleans, functions and products among
  them, and so on.
\item Type$_1$ contains Type$_0$ as well as constructions involving
  it.
\item Generally, we have Type$_i$:Type$_{i+1}$.
\end{itemize}

Modern type theories, such as those used in Coq, Agda, or Lean,
implement universes in slightly varying form. We concentrate on Agda
and review Coq and Agda in \cref{sec:related-work}.

Agda supports a hierarchy of universes. It allows us to write
definitions that are parameteric in the universe level, which is
provided as an abstract type with operations successor and maximum
(level arithmetic). Like other type theories, Agda supports different
sorts of universes, $\ASet$ and $\AProp$, containing predicative and
impredicative types, the latter being proof-irrelevant.

While parametric definitions are allowed, the level parameters range
over a type that is essentially isomorphic to the natural
numbers.
However, this approach is not sufficient as certain types that express
quantification over levels cannot be assigned a to parametric
universe. An example would be the type $T = \forall \ell \to \ASeti\ell
\to \ASeti{(\Asuc~\ell)}$. As Agda finds no $\ell$ such that $T :
\ASeti\ell$, it assigns $T : \ASeto$ (a fixed predefined universe).

In \cref{sec:types-1} and later in \cref{sec:discussion-2}, we discuss
some types that hit this bound and arise in practice. The problem with
types in universe $\ASeto$ and higher is that they are not compatible
with library definitions \cite{team25:_agda_stand_librar}. This is
because most library definitions are level polymorphic and thus not
applicable to entities that live in $\ASeto$ and higher. Examples are
lists, vectors, pairs, sums, function tools (identity, composition,
etc), and so on. One important example is the equality type.
In consequence, users of such entities need to define their own
specialized versions of lists, vectors, equality, and so on. Mostly,
it boils down to copy the existing implementation and change
$\ASet\ell$ to $\ASeto$ where appropriate. And they
have to do so for each level afresh: $\ASeto$, $\ASetoo$, $\ASetooo$, \dots

How do we propose to fix it?

Contributions.

Note on the Agda code: what is proved and what is postulated?

\section{Preliminaries}
\label{sec:preliminaries}

This paper assumes some familiarity with Agda
\cite{DBLP:conf/icfp/Norell13}, but we give the occasional hint if we
use a non-obvious feature. In this section, we mostly recall the most
important results from the literature on which we base this
work. Specifically,
\begin{itemize}
\item the treatment of universes in Agda;
\item the notion of propositional equality in Agda;
\item an Agda implementation of a useful fragment of ordinals (here we
  have to prove some extra results);
\item an inductive-recursive construction of a universe hierarchy that
  can be indexed with ordinals.
\end{itemize}

\subsection{Universes in Agda}
\label{sec:universes-agda}

Agda supports an infinite  hierarchy of universes \cite{team25:_agda_languag_refer}. It
provides an abstract datatype $\ALevel$ of universe levels along with
constants $\ASetzero$, $\ASetsuc$, and $\AgdaDatatype{\_⊔\_}$ that denote the base-level of the
hierarchy, the successor, and the maximum of two levels.
The level-parametric type $\ASeti i$ stands for the universe at level $i$
and it obeys the typing
$\ASeti i : \ASeti{(\ASetsuc~ i)}$.
Base types inhabit the universe $\ASeti{\ASetzero}$.
Type formation handles universe levels in the same way as finitely
stratified System F \cite{DBLP:journals/iandc/Leivant91}. That is,
\begin{itemize}
\item if $A : \ASeti{ i}$ and $B : \ASeti{ j}$, then $A \to B : \ASeti{
  (i ~\ASetlub~ j)}$;
\item  if  $\alpha : \ASeti i$ is a type variable and $A : \ASeti j$, then
  $\forall \alpha. A :\ASeti{ (\ASetsuc~i ~\ASetlub~ j)}$.
\end{itemize}

To avoid inconsistencies, Agda does not allow pattern matching on the
type $\ALevel$. However, quantification over $\ALevel$ is allowed and results
in a type at level $\omega$ (if the level-typed variable is used in a
significant way). Unfortunately, levels $\omega$ and higher are
\textbf{not} handled in a parametric way in Agda. Rather there are
predefined types $\AgdaDatatype{Setω}$, $\AgdaDatatype{Setω1}$,
$\AgdaDatatype{Setω2}$, and so on, for the levels $\omega$, $\omega+1$,
$\omega+2$. This design has some limitations, as most 
notions in the standard library (prominently the equality type
and its supporting infrastructure, but also parameteric
types like sums, pairs, lists, and so on) are defined in a level-parametric
way, and thus they cannot be used with $\AgdaDatatype{Setω}$ 
and higher universe levels.

For convenience, Agda's unification algorithm has special treatment
for the $\ALevel$ datatype and its operators
\cite{team25:_agda_languag_refer}:
\begin{itemize}
\item Idempotence: $i ~\ASetlub~ i$ is the same as $i$.
\item 
Associativity: $(i ~\ASetlub~ j) ~\ASetlub~ k$ is the same as $i ~\ASetlub~ (j ~\ASetlub~ k)$.
\item 
Commutativity: $i ~\ASetlub~ j$ is the same as $j ~\ASetlub~ i$.
\item 
Distributivity of $\ASetsuc$ over $\ASetlub$: $\ASetsuc (i ~\ASetlub~ j)$ is the same as $\ASetsuc~ i ~\ASetlub~ \ASetsuc~ j$.
\item 
Neutrality of $\ASetzero$: $i ~\ASetlub~ \ASetzero$ is the same as $i$.
\item 
Subsumption: $i ~\ASetlub~ \ASetsuc~ i$ is the same as $\ASetsuc~ j$. 
\end{itemize}
In other words, the level structure is a join-semilattice with an
inflationary endomorphism \cite{DBLP:journals/tcs/BezemC22}.

By default, Agda keeps universe levels separate and requires explicit
lifting to transfer values from, say, $\ASeti{ i}$ to $\ASeti{ (i
\ASetlub j)}$. A different design choice is to have cumulativity,
which means that anything inhabiting $\ASeti{ i}$ also inhabits any
higher universe $\ASeti{ (i \ASetlub j)}$. 
Agda has an option that enables cumulativity, but we are not using it
in this work as it does not fit into the framework of \cref{sec:encoding-universes}.

\subsection{Syntax and Equality in Agda}
\label{sec:eqreason}
\begin{figure}[tp]
  \begin{minipage}[t]{0.45\linewidth}
    \SFEQ
    \SFcong
  \end{minipage}
  \begin{minipage}[t]{0.45\linewidth}
    \SFsubst
    \SFcoe
  \end{minipage}
  \caption{Equality in Agda}
  \label{fig:eq-agda}
\end{figure}
Agda provides a set of operations to manipulate equality proofs.
We will discuss only the pieces most relevant for this paper.

In \Cref{fig:eq-agda} the equality datatype is defined in the usual
way. 
The definition uses Agda's mixfix syntax. 
We write $a ~\AgdaDatatype{$\equiv$}~ b$ to describe the type 
that proposes $a$ and $b$ are equal.
In general, we can write underscores in function and datatype names, 
where arguments should go in place of the underscores.
Arguments in curly brackets are referred to as implicit arguments 
(e.g. $\ell$ and $A$ in the equality datatype). 
Agda attempts to infer them automatically. 
If Agda fails to infer them,
the programmer must specify them manually using the syntax $\{a = b\}$.
The standard library includes operations to further use 
and manipulate equality proof.

A simple way to create an new equality using an existing one 
is the \AgdaFunction{cong} function.
It applies, given an equality proof  
$a ~\AgdaDatatype{$\equiv$}~ b$, a function $f$ to both $a$ and $b$
resulting in an new equality proof $f~a ~\AgdaDatatype{$\equiv$}~ f~b$.

Occasionally we use {\AgdaFunction{sym}} to transform 
an equality proof of the form $a ~\AgdaDatatype{$\equiv$}~ b$ into
proof that $b ~\AgdaDatatype{$\equiv$}~ a$. Additionally, we 
use {\AgdaFunction{trans}} to compose two proofs
$a ~\AgdaDatatype{$\equiv$}~ b$ and $b ~\AgdaDatatype{$\equiv$}~ c$,
obtaining proof that $a ~\AgdaDatatype{$\equiv$}~ c$.

The {\AgdaFunction{subst}} operation allows us to use a value of 
a type at a syntactically different, but propositionally equal, type.
The relevance of {\AgdaFunction{subst}} arises where equality proofs cannot be matched
on directly, because it witnesses the equality between two non-unifiable
expressions (e.g. between function applications: $f~x~\AgdaDatatype{$\equiv$}~g~y$).
We define $\AgdaFunction{coe}=\AgdaFunction{subst}~\AgdaFunction{id}$ 
(where \AgdaFunction{id} is the identity function) 
as a specialization for {\AgdaFunction{subst}}.
It allows coercing between two entirely equal types 
rather than substituting parts within one.


\subsection{Ordinals}
\label{sec:ordinals}

Ordinal numbers are an important concept in mathematics and computer
science. They are closely related to well-ordered sets as any
well-ordered set is order-isomorphic to an ordinal. The significance
to computer science is that such well-orders can be used for
termination proofs.

The best known construction of ordinals is a set-theoretic one due to
von Neumann. It starts with the smallest ordinal $0$ represented by
the empty set $\emptyset$. To construct the successor of an ordinal
$\alpha$, we define $\alpha+1  := \alpha \cup \{ \alpha \}$. This way,
we construct $1, 2, 3, \dots$. Then, we can scoop them all up into the
smallest limit ordinal $\omega = \{ 0, 1, 2, 3, \dots \}$, which
contains $0$ and all finite applications of the successor to it. We
continue with $\omega + 1 = \omega \cup \{ \omega \}$ and carry on
until we build the next limit ordinal $\omega \cdot 2$, then $\omega
\cdot 3$, and so on. Constructing the limit at this level yields
$\omega^\omega$ and continuing further leads to
$\omega^{\omega^\omega}$, $\omega^{\omega^{\omega^\omega}}$, and so
on. The limit of this sequence is $\varepsilon_0$ which is the
smallest ordinal that fulfills the equation
$\varepsilon_0 = \omega^{\varepsilon_0}$.

In the context of this paper, we plan to use
ordinals as universe levels where the well-ordering avoids collapsing
levels. The construction of ordinals does not stop at $\varepsilon_0$,
but we wish to carve out a particular set of ordinals that fits
well in an implementation context. Concretely, we consider ordinals
less than $\varepsilon_0$ as they can be represented by binary trees.
To see this, recall that every ordinal $\alpha$ can be written in
Cantor normal form (CNF)
\begin{align*}
  \alpha &= \omega^{\beta_1} + \omega^{\beta_2}  + \dots + \omega^{\beta_n}
\end{align*}
for some $n\ge0$ and ordinals $\beta_i$ such that
$\beta_1\ge\beta_2\ge \dots \ge \beta_n$. If $\alpha < \varepsilon_0$,
then it can be shown that each exponent satisfies $\beta_i < \alpha$.
If we, again, write $\beta_i = \omega^{\gamma_1} + \dots +
\omega^{\gamma_m}$ in Cantor normal form, then clearly $\gamma_j <
\beta_i < \alpha$. As the ordering on ordinals is a well-order, we
know this decreasing sequence must terminate and we obtain a finite 
and unique representation for each ordinal less than $\varepsilon_0$.

\citet{DBLP:conf/cpp/ForsbergXG20} developed Agda
formalizations for three equivalent representations for precisely this
set of ordinals. They define addition and multiplication of ordinals,
prove the principle of transfinite induction, and use that to prove
that the represented subset of ordinals is well-ordered.

We build on one of their representations, called {\AMutualOrd}, define
some additional operations, and prove some properties which are needed
in the context of universe levels.\footnote{Technically, the
mechanization of \citet{DBLP:conf/cpp/ForsbergXG20} relies on
cubical Agda \cite{10.1145/3341691}. We back-ported the definitions for
MutualOrd to standard Agda, as cubical is not needed for this representation.}
In particular, we prove the laws of a join-semilattice with an
inflationary endomorphism.

\begin{figure}[tp]
  \begin{minipage}[t]{0.52\linewidth}
    \OMDecl \OMDef
  \end{minipage}
  \begin{minipage}[t]{0.37\linewidth}
    \OfstDef \OOrdDef
  \end{minipage}
  
  \caption{\AMutualOrd}
  \label{fig:def-mutualord}
\end{figure}
The \AMutualOrd~ representation defines ordinals in CNF by\Cref{fig:suc-max}
induction-recursion as a binary tree structure 
together with the order invariant (see \cref{fig:def-mutualord}).
When constructing the ordinal $ω^\alpha + \beta$, 
we require $\alpha$ to be greater than or equal to the first exponent of $\beta$.
Thus, this inequality is included in the representation. To this end,
the definition includes datatype {\AMutualOrd} itself; the function \AgdaFunction{fst}, 
which obtains the leading exponent of an ordinal; and the strict order
on {\AMutualOrd}. 
Here we use \OGtDef~. 
This definition is correct by construction.

Here are some examples of ordinals in this representation.
\vskip.5\baselineskip
\begin{minipage}{0.33\linewidth}
    \LMOExA 
  \end{minipage}
  \begin{minipage}{0.33\linewidth}
    \LMOExB
  \end{minipage}
  \begin{minipage}{0.33\linewidth}
    \LMOExC
\end{minipage}
\vskip.5\baselineskip
In addition to the definitions from \citet{DBLP:conf/cpp/ForsbergXG20} 
we define the successor and maximum operations for \AMutualOrd~ and then proceed to proof the laws of the join-semilattice.

\begin{figure}[tp]
  \begin{minipage}{0.55\linewidth}
    \LMOlub
  \end{minipage}
  \begin{minipage}{0.35\linewidth}
    \LMOsuc
  \end{minipage}
  \caption{Successor and maximum for $\AMutualOrd$}
  \label{fig:suc-max}
\end{figure}
\Cref{fig:suc-max} contains the definitions of maximum and successor.
The successor operation pushes a \AgdaFunction{$\mathbf{1}$}  down the
right spine of the representation.
The inductive case has to manipulate the proof component accordingly.
The maximum operation first compares the exponents and, if the exponents are equal, the rest of the sum
to determine which ordinal is the maximum.
The function \AgdaFunction{<-tri} compares two ordinals.
Given two \AMutualOrd~ $a$ and $b$ the function gives proof, 
that $a$ is either smaller, bigger or equal to $b$. 

% Note that, in the very last case of the definition of 
% \AgdaFunction{$\_\sqcup_o\_$} it does not matter which ordinal we chose.

Given our additional definitions, we can prove the laws of a join-semilattice. 
In the following equations $a$, $b$ and $c$ range over arbitrary 
expressions of type \AMutualOrd. 
\vskip.5\baselineskip
\begin{minipage}{0.6\linewidth}
  Associativity: \LAssoc \\
  Commutativity: \LComm \\
  Distributivity: \LDist
\end{minipage}
\begin{minipage}{0.4\linewidth}
  Idempotence: \LIdem \\
  Neutrality: \LNeut \\
  Subsumption: \LSubsum
\end{minipage}
\vskip.5\baselineskip
Proving these laws is fairly mechanical, the only exception is the
subsumption proof, where we generalize from the successor as
implemented in Agda.
To prove subsumption in its general form, we define a predicate 
$a$ \AgdaFunction{$\in'$} $b$ that points to the location of $a$ in $b$ 
and from that we can prove that $a ⊔ b$ must be equal to $b$.

\subsection{Encoding Universes}
\label{sec:encoding-universes}

While Agda has built-in support for universes, it is possible to
``compress'' certain universe hierarchies into
$\ASet$. \citet{DBLP:conf/csl/Kovacs22} constructs a very general model
of cumulative universe hierarchies, which is situated entirely in $\ASeti{0}$
and $\ASeti{1}$. The construction requires induction-recursion
\cite{DBLP:conf/tlca/DybjerS99}, so that the model can be constructed
in Agda along with its consistency proof.

Kov\'{a}cs's implementation in Agda is along the lines of
\citet{mcbride15:_datat_datat}'s universe construction. Here we just
recall the most important definitions of his construction of TTDL
(type theory with dependent levels).

A \emph{level structure} provides a set $\AgdaField{Lvl}$ of levels, a strict
linear order $\AgdaField{\_<\_}$, evidence that this order is propositional, and a
composition operator that embodies transitivity of the
order. Universes can be indexed by any level structure, for example,
natural numbers for ordinals less than $\omega$, pairs of natural
numbers for ordinals less than $\omega+\omega$, and in fact any
type-theoretic ordinal.

\ULvlStruct

The inductive type \AgdaDatatype{U$^{ir}$} of universe codes is defined mutually
recursively with its interpretation \AgdaFunction{El$^{ir}$} in $\ASet$.

\begin{minipage}{0.45\linewidth}
\UUirSpec
\UUir  
\end{minipage}
\begin{minipage}{0.45\linewidth}
\UElirSpec
\UElir
\end{minipage}

The actual universes are defined by induction on the accessibility of
levels. Accessibility is formalized in the standard way by the type
$\AAcc$ with single constructor $\Aacc$.
\UUless
With that we define the semantic hierarchy and its decoding function.

\begin{minipage}{0.45\linewidth}
  \UU
\end{minipage}
\begin{minipage}{0.45\linewidth}
  \UEl
\end{minipage}

To fit in with the way that stratified System~F (as well as Agda)
handles levels, we need a non-strict lift operator on universes and
proof that lifting does not change the semantic representation.

\begin{minipage}{0.45\linewidth}
  \ULiftLe
\end{minipage}
\begin{minipage}{0.45\linewidth}
  \UElLiftLe
\end{minipage}

With these operators, Kov\'{a}cs defines an alternative $\Pi$-type encoding that fits perfectly
with the requirements of stratified System~F, namely that the level of
a function type is the maximum of the levels of argument and return types.
\UAltPi

Here, $\sqcup_1$ and $\sqcup_2$ are proofs that the first (second)
argument of $\sqcup$ is less than or equal to their maximum. The
function {\Acoe} transforms a type by applying an equality to it.
% TODO explain that coe is subst id

There is also a definition of a non-dependent function code.

\UFun

\citet{DBLP:conf/csl/Kovacs22} also provides a worked example of a
level structure for ordinals up to $\omega+\omega$, corresponding to
the current version of Agda, as well as some infrastructure for
using type-theoretic ordinals as levels.

\section{Running Example}
\label{sec:running-example}

As a running example for demonstrating various encodings, we consider
different extensions of finitely stratified System F
\cite{DBLP:journals/iandc/Leivant91}. More precisely, we start from an
intrinsically typed encoding of types and expressions, then we
construct denotational semantics for different encodings and discuss
their respective merits.

We choose this system as it is significant, presents non-trivial
challenges, and it has been studied in the literature. Our encoding of
syntax is inspired by \citet{DBLP:conf/mpc/ChapmanKNW19}, who develop
the syntactic metatheory of System-F$\omega$ (without
stratification). It has been  picked up by
\citet{DBLP:conf/tyde/Saffrich0W24}, who give denotational and operational semantics
for finitely stratified System-F and develop a logical relation for
it. \citet{DBLP:journals/pacmpl/HubersM23} use a similar syntax
representation for a finitely stratified version of System-F$\omega$
extended with qualified types. They also develop a denotational
semantics for their calculus. All these papers come with Agda
formalizations. 

The following subsections gives some excerpts from our Agda
formalization which is available as supplemental material. We
generally omit definitions for renamings and substitutions in the
paper as they closely follow the abovementioned references. While the
definitions are available in the supplemental material, some
scaffolding lemmas (e.g., about composition of substitutions) are only
postulated as their proofs can either be found in the abovementioned
references or their proofs are very similar to proofs found there. 

\subsection{Types}
\label{sec:syntax-types}

We start with an intrinsically-typed encoding of types and expressions
of finitely stratified System~F. Like
\citet{DBLP:conf/tyde/Saffrich0W24} and
\citet{DBLP:journals/pacmpl/HubersM23}, we rely on Agda's $\ALevel$
type to represent levels syntactically. This choice has the advantage
that Agda's special treatment applies to syntactic levels (see
\ref{sec:universes-agda}). The representation of a type variable
context is {\SFTEnv} ranged over by $\Delta$.

\begin{figure}[tp]
  \SFType
  \caption{Syntax of types}
  \label{fig:native-type-syntax}
\end{figure}
Types $T$ in \cref{fig:native-type-syntax} take a type variable
context $\Delta$ as a parameter and a level 
index. The variables $\ell$, $\ell_1$, \dots{} range over
$\ALevel$. The construction is standard. Base types live at level
$\ASetzero$; function types live at the maximum level of argument and
return types; type variables are
represented by their position in the type variable context, i.e.,
as de Bruijn indices; and
universal quantification introduces a new type variable at level $\ell$.

\begin{figure}[tp]
  \begin{minipage}{0.45\linewidth}
    \SFEEnv
  \end{minipage}
  \begin{minipage}{0.45\linewidth}
    \SFEEnvNi
  \end{minipage}
  \caption{Variable contexts}
  \label{fig:native-variable-contexts}
\end{figure}
Variable contexts $\Gamma$ in \cref{fig:native-variable-contexts} are indexed by a type variable context. They
are either empty, bind a variable to a type, or bind a type variable
to a level. Correspondingly, variable access \AgdaDatatype{$\_\ni\_$} has two ways to
skip over a binding. Accessing a variable across a type variable
binding (in \Atskip) requires weakening the type found before the type
binding.\footnote{{\ATwk} is a standard renaming on types that
  performs weakening.}

\subsection{Expressions}
\label{sec:syntax-expressions}

\begin{figure}[tp]
  \SFExpr
  \caption{Syntax of expressions}
  \label{fig:native-expression-syntax}
\end{figure}
Expressions $e$ in \cref{fig:native-expression-syntax} take a variable context $\Gamma$ as a parameter and are indexed
by a type, as usual. The first five cases are standard as for
simply-typed lambda calculus. The type-lambda takes the level of the
new type variable and a body expression that is typed in a
level-extended variable context to construct an expression of type
\AgdaDatatype{$\forall\alpha$}~ $T$. Type application takes such an expression and a
type of suitable level to construct an expression of type $T$\AgdaDatatype{$[$}$T'$\AgdaDatatype{$]$T},
that is, substituting the first variable in $T$ by $T'$.

\section{Native Agda Semantics}
\label{sec:semantics}

The denotational semantics we consider here consists of two parts: the semantics of
types and the semantics of expressions. Both semantics are
compositional.

This section explores mappings of types and expressions to
corresponding Agda domains that are as direct as possible, hence the
name ``native''.

\subsection{Types}
\label{sec:types-1}


The native semantics maps a type at level
$\ell$ to $\ASeti\ell$. Due to the presence of type variables, the
semantics needs a type variable environment that maps a type variable
to its denotation. There are several options in defining this
environment.

\begin{enumerate}
\item We may define it as a function as follows:
  \SFFTSEOmega
  This definition lives in Agda's (fixed) $\ASeto$, so
  that equational reasoning at the type becomes inconvenient.
\item We may also define it as an inductive datatype
  \SFFTSEInductive
  Again, this definition lives in $\ASeto$, although we might think of
  defining a function that computes the level of the defined type from
  the levels of the type variable context:
  \SFTEnvLub
  However, we cannot use this function as an argument to $\ASeti\_$
  because Agda does not let us to define an inductive datatype where
  the level depends on an index type. 
\item Finally, we define the environment by induction as a heterogenous list:
  \SFFTSEAsFunction
\end{enumerate}
We adopt the last alternative to stay below $\ASeto$ and define the type semantics:
A type at level $\ell$ is interpreted as an element of $\ASeti\ell$.
\SFTypeSem


\begin{remark}
  The key to make this semantics readable lies in our choice of the
  $\ALevel$ datatype for syntactic levels. If we chose, e.g., natural
  numbers for syntactic levels, the definitions for function types and
  universal types would become cluttered with transport lemmas caused
  by the injection function $\AtoLevel : \ANat \to \ALevel$. In the
  case of function types, the proof obligation would be
  $\AtoLevel~l_1 \sqcup \AtoLevel~l_2 \equiv \AtoLevel~ (l_1~$\AgdaFunction{$\sqcup_ℕ$}$~l_2)$. As demonstrated in Section~\ref{sec:level-quantification},
  transport lemmas in the semantics of types are to be avoided because
  they proliferate into the semantics of expressions.
\end{remark}

\subsection{Expressions}
\label{sec:expressions-1}



For the expression semantics, we also need a variable environment.
We define it analogously to the type variable environment, with a
function to compute the maximum level in the environment and another
to build the environment structure. The latter is not surprising:
nested pairs of values.

\begin{minipage}{0.45\linewidth}
  \SFEEnvLub
\end{minipage}
\begin{minipage}{0.45\linewidth}
  \SFFESEAsFunction
\end{minipage}

\begin{figure}[tp]
  \SFESem
  \caption{Expression semantics}
  \label{fig:native-expression-semantics}
\end{figure}
The first five cases of the expression semantics in \cref{fig:native-expression-semantics} correspond again to
the analogous construction for the simply-typed lambda calculus. The
interpretation of a type-lambda at level $\ell$ is a function that
takes an element $A : \ASeti\ell$ and stores it in the type variable
environment. The interpretation of a type application is essentially
the interpretation of its underlying expression $e$, but the type has
to be adjusted according to the type substitution. The type of the
required equality $\Aeq$ shows that we trade the type interpretation
of $T'$ in the type variable environment for the substitution of $T'$
into $T$. The lemmas involved are straightforward substitution
lemmas. 

\subsection{Discussion}
\label{sec:discussion-1}

To wrap up, the construction of a native Agda semantics for stratified
System~F is not too hard. One crucial point is choosing a good
definition for the type variable environment. Because we chose a
definition that does \emph{not} require $\ASeto$, all equalities (in
particular $\Aeq$ in the interpretation of type application) live in a
suitable level-indexed universe and can be handled homogeneously by
library definitions.

The transport equality $\Aeq$ in the
interpretation of expressions  appears to be unavoidable. So is another
equality (not shown) in the definition of $\Alookup\textit{-}\gamma$.

A final crucial point: The interpretation of types requires no transports because types are
indexed by Agda's $\ALevel$ type, which is treated 
specially by Agda's normalization and unification procedures.

\section{Level Quantification}
\label{sec:level-quantification}
\begin{figure}[tp]
  \IRLvl
  \caption{Level expressions}
  \label{fig:level-expressions}
\end{figure}

As a new twist, we add level quantification (as in Agda) to the source
language. To this end, we need a new syntactic category: level
expressions in \cref{fig:level-expressions}. They take a level variable context {\IRLEnv} (ranged over
by $\delta$) as a parameter and are
indexed by a $\AMode$, ranged over by $\mu$. The former determines the
level variables that may appear and the latter determines whether a level
expression denotes a finite level, less than $\omega$ ($\Afin$), or if
it is unrestricted ($\Aany$).

From the indices we can see that level variables range over finite
levels, the successor and maximum operators can be used with finite
and unrestricted levels, and any expression containing $\omega$ is not
finite. From the structure of level expressions, we can see that all
denoted levels must be smaller than $\omega + \omega$. 

\begin{figure}[tp]
  \begin{minipage}{0.45\linewidth}
    \IRLSemFin
  \end{minipage}
  \begin{minipage}{0.45\linewidth}
    \IRLSemAny
  \end{minipage}
  \caption{Level expression semantics}
  \label{fig:ir-semantics-level-expressions}
\end{figure}
Consequently, \cref{fig:ir-semantics-level-expressions} defines two interpretation functions for level
expressions, one for finite expressions and a general one. We map
finite expressions to natural numbers and general expressions to pairs of natural numbers $(i, j)$
representing the ordinal $\omega\cdot i + j$. 
Both are relative to an interpretation \AgdaFunction{⟦\_⟧δ} of the level variables as
finite levels, that is, natural numbers. Elements of such a level
environment are essentially vectors of natural numbers.

\IRLEnvSem

\subsection{Types}
\label{sec:types}

The definition of a type variable context and indexing into it is
analogous to the construction of \emph{expression} variable contexts
and indexing in Section~\ref{sec:syntax-expressions}.  We use $\Alskip$ to skip
over level bindings and $\ALwk$ for weakening of level expressions.

\begin{minipage}{0.45\linewidth}
  \IRTEnv
\end{minipage}
\begin{minipage}{0.45\linewidth}
  \IRTEnvNi
\end{minipage}
\begin{figure}[tp]
  \IRType
  \caption{Syntax of types (revised)}
  \label{fig:ir-type-syntax}
\end{figure}

The syntax of types in \cref{fig:ir-type-syntax} is also very similar to the one from
Section~\ref{sec:syntax-types}, with the following differences:
\begin{enumerate}
\item The type variable context is indexed by level context $\delta$.
\item The index of type $\ALevel$ is replaced by an unrestricted level
  expression. It is unrestricted because the type of an expression can
  have level $\omega$ or higher due to the presence of level
  quantification.
\item Level quantification $\forall\ell$ pushes a new level variable on
  the level context. It conservatively assumes that the new variable
  is used in a non-trivial way in the body of this abstraction. Hence,
  the level of this type is at least $\omega$.
\end{enumerate}
This structure models the provisions of Agda: There is level
quantification over finite levels and this quantification may push
levels to $\omega$ and higher, but all levels stay below $\omega+\omega$.

Starting with the semantics of a type variable context, we draw from
the inductive-recursive universe construction explained in
\cref{sec:encoding-universes}. Our interpretation of
types takes two steps. The first encoding step interprets types as
codes; the second step interprets these codes. Hence, a type variable
context is interpreted as a vector of codes where a type variable at
level $l$ is mapped to a code for universe level $l$. (Recall that $l$
is a level expression that has to be interpreted first.)

\IRFTSEAsFunction

\begin{figure}[tp]
  \IRencode
  \caption{Encoding of types}
  \label{fig:ir-encoding-types}
\end{figure}
\Cref{fig:ir-encoding-types} contains the encoding function for types.
The encoding of the $\ANat$ type is obvious.  Type variables are
looked up in their environment. Function types are mapped to a
non-dependent function code after lifting argument and result codes to
their maximum level.

The encoding of universal quantification \AgdaDatatype{$\forall
\alpha$} $: l. T$ (with $T$ at level $l'$) involves a $\Pi$-type. The
argument of this $\APi$-code is a type at some level 
$l$, so we have to give a universe code $\AUp$ with an argument $pu$ that selects the correct
level with a proof that it is strictly before the current one in the
ordering. The current level is prescribed by type formation: $(\Asuc~
l) \sqcup l'$. Now we reason $l < \Asuc~l \le (\Asuc~ l) \sqcup l'$,
which is precisely the type of $pu$.

The second argument of $\APi$ takes some $\AElir~(\AUp~pu)$, which---by our
construction---happens to be a universe of level $l$, so we can extend
the environment $\eta$ with it. However, we can only do so after
fixing the accessibility proof in its type with the transport equality
$eq$. We finish by constructing the encoding of type $T$ in the
extended environment and lift the resulting code at level $l'$ to
$(\Asuc~ l) \sqcup l'$. 

For the encoding of level quantification, we have to remember that
quantification ranges over finite levels, i.e., natural numbers. Hence
the code is a function $\APi$ with first argument $\ANatp$. The second
argument takes some $\AElir~\ANatp$, that is a natural number
$\ell$. It remains to encode $T$ in the extended level variable
environment, eliminate the weakening from $T$'s level with a transport
equality and lift the resulting code to a level $\ge \omega$ to
compensate for the level quantification.

The semantics of a type is then a set obtained by interpretation of
the code.

\IRTSem

\subsection{Expressions}
\label{sec:expressions}

For expressions, we follow the same schema as before in
Section~\ref{sec:syntax-expressions}. However, the expression context
(ranged over by $\Gamma$)
now registers \emph{three} different kinds of bindings: types of
variables, levels of type variables, and level variables.
Correspondingly, the indexing machinery for variables also has
additional constructors $\Atskip$ and $\Alskip$ to skip over type
variable and level variable bindings.

\begin{minipage}{0.45\linewidth}
  \IREEnv
\end{minipage}
\begin{minipage}{0.45\linewidth}
  \IREEnvNi
\end{minipage}

We shall not repeat the cases for numbers, variables, lambda, etc as
they are essentially identical to what we have seen before in
Section~\ref{sec:syntax-expressions}. It remains to discuss the new
expression formers, level abstraction and level application.
Level abstraction \AgdaInductiveConstructor{$\Lambda\ell$} pushes a new level variable on the
expression context and the type variable context. Level application
\AgdaInductiveConstructor{$\_\bullet\ell\_$} takes a level abstraction and applies it to a finite
level. The resulting expression substitutes the level expression for
the level variable in the body of the level abstraction.

The implication of having level abstraction and level application is
that our framework has to support substitution of level expressions in
level expressions and types.  Level application uses $T$\AgdaDatatype{$[$}$l'$\AgdaDatatype{$]$TL}
for substituting level expression $l'$ for the first level variable in $T$.

\IRExpr

We skip the definition of variable environments
\IRTEnvSemDisplay. They are defined by 
induction on expression variable contexts as a nested pair of the
semantics of the respective types. The construction skips over
non-value bindings $\Atskip$ and $\Alskip$.
% \IRTEnvSem

\begin{figure}[tp]
  \IRESem
  \caption{Expression semantics}
  \label{fig:ir-expression-semantics}
\end{figure}
Moving to the expression semantics in
Figure~\ref{fig:ir-expression-semantics}, the cases for variables and 
numbers are straightforward. But then things go south.
\textbf{We include the full text of this definition to convey an
  impression of its complexity. Readers are not expected to study
  these details on paper, but are invited to do so in the accompanying
  code.}
The level liftings that are part of the encoding of the function type
have to be reflected as transport equalities in the cases for
abstraction and application. Without going into details, in each case, we have to lift the
argument up to the common maximum level and then the result down to
its expected level. This requirement is particularly annoying as the
representations of the types are the essentially same on all levels
(as evidenced by the equality \AElLiftLe).

Similarly, the liftings from the  encoding of the universal type have
to be reflected as transport equalities. For type application, we
still have to deal with the same phenomenon as in
Section~\ref{sec:semantics}, where we had to trade type substitution
for type environment extension. This important detail gets lost in the
noise: the ``unavoidable'' proof step is in $eq_5$ hiding in the lemma
$\ATTT$.

Finally, the cases for level abstraction and application suffer from
the same problems. However, besides compensating for the level
lifting, there are two unavoidable transfers involved, one is proved
as the lemma $\Acrucial$ and the other as $\ALTT$. $\Acrucial$
accounts for the fact that interpreting a weakened level expression in
an extended level environment yields the same results as just
interpreting the level expression in the original level
environment. $\ALTT$ trades a level substitution (into a type) for a
level environment extension.


\subsection{Discussion}
\label{sec:discussion}

The construction of universe levels by induction-recursion is
elegant and allows us to stay firmly within $\ASet$ (and $\ASetOne$).
However, using such an encoding for interesting examples turns out to
be painful, because the encoding has to account explicitly for level
subsumption aka lifting. The presence of lifting aggravates the
inherent problems with transport lemmas that arise naturally in the
elimination forms for universal types and level quantification.

Admittedly, the definitions in this section do not tap into the full
power of the encoding. While we restrict level quantification to
finite levels (i.e., natural numbers), the framework of
\citet{DBLP:conf/csl/Kovacs22} can 
reflect the full level structure into the object language. Due to
the choice of example, we do not venture into dependent types and we
do not make  use of a $\ASet$-like type, all of which would be
possible within the framework.

On a final note, it is possible to express the semantics of level quantification
``natively'' within Agda. Doing so is cumbersome and not fully general
(i.e., restricted to universes up to $\ASeto$), because it requires
defining a datatype at level $\omega+1$ that either contains a $\ASeti\ell$ or a $\ASeto$.
For that reason, we only defined a semantics using Kov\'acs's
construction.

\section{Back to Native Semantics}
\label{sec:back-native-semant}

One key point in the construction of an uncluttered semantics in
Section~\ref{sec:semantics} is the special treatment of the type
$\ALevel$ by Agda's normalization and unification. In this section, we
work in a hypothetical extension of Agda where the $\ALevel$ type
contains limit ordinals, too. More precisely, we propose to work with
ordinals less than $\varepsilon_0$ represented in Cantor normal form
as elements of $\AMutualOrd$ (cf.\ Section~\ref{sec:ordinals}).

Even though this extension is hypothetical, we can give a taste of it
by augmenting the level datatype with extra elements and laws using
suitable postulates.

As our target is the same calculus as in
Section~\ref{sec:level-quantification}, we can reuse the syntax along
with all sorts of typing context. Of course, we redefine all
environments as well as the actual semantics.

\subsection{Extended Hierarchy}
\label{sec:extended-hierarchy}

To construct an extended hierarchy of universes, indexed by ordinals
represented by $\AMutualOrd$, 
we start by postulating a new (unsafe) constructor of levels, which is
essentially the branching constructor of $\AMutualOrd$. It is unsafe
to use this constructor directly because it does not enforce the order invariant of $\AMutualOrd$.

\LCantor

The safe interface for constructing levels beyond $\omega$ is an
injection function from $\AMutualOrd$ to $\ALevel$.

\LtoLevel

\begin{figure}[tp]
  \LAxioms
  \caption{Axioms for level equality}
  \label{fig:axioms-level-equality}
\end{figure}
In Figure~\ref{fig:axioms-level-equality}, we postulate some equality
laws for the level constructor. As we cannot verify them using the
$\ALevel$ type, we check their soundness for $\AMutualOrd$.
The first two laws hold definitionally for the definition of $\Asuc$
for $\AMutualOrd$. We proved the soundness of the other three
equalities for $\AMutualOrd$.
Moreover, we prove that $\AMutualOrd$ with $\Asuc$ and $\sqcup$ fulfills all laws
for a join-semilattice with an inflationary endomorphism, which is the
requirement for Agda's special treatment of $\ALevel$ to work.

In other words, Agda will do most of the simplification of levels with
its built-in ``magic'', but it will need occasional help of the
programmer if the above axioms are needed. To this end, we define some
cast operations that manipulate the level index of the $\ASet$ type.

\Lcast

\begin{remark}
  The cognoscenti will be reminded of the $\Asubst$ function from the
  Agda library, but this function is not applicable because it
  abstracts over a predicate $P : A \to \ASeti\ell$, for some fixed
  level $\ell$. In our case, a \emph{dependent} predicate
  $P : (\ell : \ALevel) \to \ASeti{(\Asuc~\ell)}$ ist needed. (It is
  easy to extend $\Asubst$ accordingly.)
\end{remark}

\subsection{Bounded Levels}
\label{sec:bounded-levels}

Now that we squeeze a much larger fragment of the ordinals into the
$\ALevel$ type, we need to be able to restrict level quantification to
(limit) ordinals of our choosing. To this end, we define a machinery
for bounding levels with an ordinal. It culminates in a record that
pairs a level with the proof that it is strictly smaller than its bound.

\BQBoundedLevel

The crux of this seemingly obvious definition is the definition of the
underlying order $\_<\_$ on levels. We define it axiomatically,
extending an alternative definition of $\le$ on natural
numbers.\footnote{Viz.\ the definition of $\le'$ on natural numbers in
  the standard library.} The order is defined as a datatype so that we
can perform induction on the order. This way we avoid pattern matching
on the $\ALevel$ datatype, which is not permitted in Agda. This
restriction also dictates the form of the axioms where the outcome
always has the form $\ell \le \dots$, i.e., the left side is a variable.

\begin{minipage}{0.45\linewidth}
  \BQLevelLe
  \BQLevelLt
\end{minipage}
\begin{minipage}{0.45\linewidth}
  \BQLim
  \BQAxiomsLe
\end{minipage}

We need two further axioms, which do not fit into the required schema
for constructors of the \AgdaFunction{$\_\le\_$} type. The axiom {\ALeLubLub} has a maximum on
the left side of the relation and {\ALtSucLim} has a successor on the
left side. The latter expresses the fact that we can always squeeze
another ordinal between a limit ordinal $\beta$ and some
$\alpha<\beta$, namely $\alpha+1$. To this end, the datatype $\ALim$
characterizes limit ordinals (in $\AMutualOrd$): they need to end in
$\omega^k$, for some $0<k$. 
% TODO: explain that these could (maybe?) be proven  
% if level constructors would assume injectivity?

We proved all axioms for the $\AMutualOrd$ representation.

\begin{figure}[tp]
  \BQBoundedLift
  \caption{Bounded lifting}
  \label{fig:eh-bounded-lifting}
\end{figure}
Similar to the encoding semantics in
Section~\ref{sec:level-quantification}, we sometimes need to lift
levels explicitly, but only in connection with level
quantification. Figure~\ref{fig:eh-bounded-lifting} gives the
definition, which relies on the {\ALift} type from Agda's level
infrastructure. We only show the typing part, the expression part is
defined similarly. The key is that this definition is by induction on
the level order \AgdaFunction{$\_\le\_$}. The definition of the order is such that
the definition of lifting does \emph{not} require pattern matching on
the $\ALevel$ type.

Using the above definitions we can add a fourth alternative for the 
encoding of semantic type environments described in Section \ref{sec:types-1}.

\SFVarLess
\SFFEnv

The lemma \AgdaFunction{ℓ∈Δ⇒ℓ<⨆Δ} proves, without the need to match on levels, that
if a type variable is to be found inside $\Delta$, then its level $\ell$ must be less than
\AgdaFunction{suc⨆Δ} $\Delta$.
We then proceed to fix the issue with the first option mentioned in Section \ref{sec:types-1},
namely that the function ends up in \AgdaDatatype{Set$\omega$}, 
by using bounded level quantification over \AgdaFunction{suc⨆Δ} $\Delta$.
As a result, our function lives in \AgdaDatatype{Set}$($\AgdaFunction{suc⨆Δ} $\Delta)$ 
instead of \AgdaDatatype{Set$\omega$}.
The only inconvenience is that we are required to always return a \ASet~
that lives exactly in \AgdaDatatype{Set}$($\AgdaFunction{suc⨆Δ} $\Delta)$.
Hence we use \AgdaFunction{BoundedLift} to account for that.
In return, we require explicit (un-) lifting to define the associated insert or lookup operations.
For that reason we stuck to the heterogenous list approach.

\subsection{Semantics}
\label{sec:semantics-1}
\begin{figure}[tp]
  \begin{minipage}[t]{0.45\linewidth}
    \EHLSemFin
  \end{minipage}
  \begin{minipage}[t]{0.45\linewidth}
    \EHLSemAny
  \end{minipage}
  \caption{Level expression semantics}
  \label{fig:eh-semantics-level-expressions}
\end{figure}

A level environment is still a vector of levels, but now we make it
explicit that the levels are less than $\omega$.

\EHLEnvSem

The definition of the semantics of finite level expressions (Figure~\ref{fig:eh-semantics-level-expressions}) is
slightly involved because we need to include proof that all results
are bounded by $\omega$. To this end, we need some of our axioms along
with the following lemma:
\EHzeroLtomega

The semantics of general level expressions is (almost) the same as
before: we forget the bound when projecting from a finite level
expression. 

\EHFTSEAsFunction

This definition of the type environment looks very similar to the
definition from Section~\ref{sec:types-1}. The difference is that
$\Delta$ now contains (finite) level expressions, which we have to
interpret to get the actual element of $\ALevel$ to index
$\ASet$. Moreover, the interpreted level is just some symbolic value
that can stand for any ordinal in the range of our representation.

\begin{figure}[tp]
  \EHTSem
  \caption{Type semantics}
  \label{fig:eh-semantics-types}
\end{figure}
The semantics of types (Figure~\ref{fig:eh-semantics-types}) has
become readable, again. The cases for function types and universal
types look like in Section~\ref{sec:types-1}. For level abstraction,
the bound $\omega$ has to be stated and we have to lift the level of
the body to (symbolic) level $\omega$. As before, we need to address
the weakening by a transport lemma \AgdaFunction{⟦Lwk⟧L} about level
expression renamings.

The semantics of environments $\Gamma$ is defined as before, but with
the current semantics of types.
\begin{figure}
  \EHESem
  \caption{Expression semantics}
  \label{fig:eh-expression-semantics}
\end{figure}

Figure~\ref{fig:eh-expression-semantics} defines the expression
semantics. It also has become more readable, again. All cases up to
(including) type abstraction do not require any transport lemmas. The
case for type application applies the usual transport to compensate
the type substitution. Level abstraction and level application suffer
from the lifting needed in the definition of their type semantics and
we need to compensate the level substitution. The functions
\AgdaFunction{cast-intro} and \AgdaFunction{cast-elim} transform the
types according to the casts used in the type semantics.

\subsection{Discussion}
\label{sec:discussion-2}

This section demonstrates the benefits of having an extended system of
universe levels in a proof assistant like Agda. Compared to the
approach in Section~\cref{sec:level-quantification}, we save
significantly on boilerplate in the form of transport lemmas. The
presence of transport lemmas decreases the readability of
definitions. Moreover, if transports are required at the type level,
they creep into the expression level and into proofs, making them tedious.
% and even more into the lemmas about the interaction between type and expression
% semantics and substitution!

We believe this section also demonstrates that one could extend Agda's
system of universe levels in an upward compatible way to ordinals less
than $\varepsilon_0$. We proved that Agda's current treatment of
levels is still sound. For our experiments, we postulated a
constructor for levels in Cantor normal form and we proved some
equalities for ordinal levels sound and used them to rewrite symbolic
levels using explicit casts. A real implementation would add a syntax
for ordinal literals and integrate the equalities as rewrite rules
(the rewrite extension of Agda does not permit us to rewrite levels to
avoid paradoxa). Also, lifting to a {\ABoundedLevel} could be
internalized to avoid casting in \cref{fig:eh-semantics-types} and
\cref{fig:eh-expression-semantics}. 


While our running example does not tap into the
full power of this extension, it is easy to envision a formalization
of a version of (infinitely) stratified System~F with bounded level quantification,
where the bound can be any ordinal expressible with $\AMutualOrd$. The
resulting system might even be simpler than the one discussed here,
because we would not have to distinguish between finite and general
level expressions.



\section{Related Work}
\label{sec:related-work}

\citet{10.1093/oso/9780198501275.003.0012} presents a general and
historical overview of the notion of a universe in type theory.

\citet{voevodsky14} develops a type system with universe polymorphism.

\citet{DBLP:conf/csl/Kovacs22}

\citet{DBLP:conf/types/BezemCDE22}

\citet{DBLP:journals/pacmpl/PoiretGMPSTT25} introduce sort
polymorphism and study its metatheory. Sort polymorphism enables us to
write definitions independent of which particular universe (hierarchy)
they are situated in. So this notion lives one level higher than
universe polymorphism.

\subsection{Universes in Coq}
\label{sec:universes-coq}

Coq supports a cumulative hierarchy of type universes and employs a
constraint-solving mechanism to manage them automatically \cite{DBLP:journals/pacmpl/SozeauBFTW20,DBLP:conf/itp/SozeauT14}. 
Coq has an infinite hierarchy of universes
\( \text{Type}_0 \), \( \text{Type}_1 \), \( \text{Type}_2 \), … where:
\(\text{Type}_i : \text{Type}_{i+1} \).
This hierarchy is cumulative, i.e., \(\text{Type}_i \subseteq \text{Type}_{i+1} \) .

Coq does not assign fixed levels to universes and it does not support
level arithmetic. Instead, it assigns 
universe variables and generates universe constraints during type
checking \cite{Herbelin2005TypeIW}. Type checking fails, if the constraints have no solution.

%%% Sorts in Coq: Prop, Set, and Type**

\subsection{Universes in Lean}
\label{sec:universes-lean}


Lean handles universes in a way similar to Coq and Agda where
universes are usually managed automatically, but explicit handling is possible when needed.
As in Coq, there is a cumulative hierarchy of universes.
Definitions can be parametric in universe levels.
Lean provides level arithmetic via max (maximum) and lift (move to a
higher universe).

% Sorts in Lean: Sort 0 - Prop, Sort 1 - Type 0, Sort 2 - Type 1, and
% so on

Lean's type theory is explained in detail by \citet{carneiro19:_type_theor_lean}.



\section{Conclusions}
\label{sec:conclusions}


%%
%% The acknowledgments section is defined using the "acks" environment
%% (and NOT an unnumbered section). This ensures the proper
%% identification of the section in the article metadata, and the
%% consistent spelling of the heading.
\begin{acks}
  To whom it may concern.
\end{acks}

%%
%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{ACM-Reference-Format}
\bibliography{references}


\end{document}
\endinput
