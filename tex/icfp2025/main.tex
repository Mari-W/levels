\documentclass[manuscript,screen,review,anonymous]{acmart}
\usepackage{cleveref}
%%
\usepackage{agda}

%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    Bib\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmlicensed}
\copyrightyear{2018}
\acmYear{2018}
\acmDOI{XXXXXXX.XXXXXXX}
%% These commands are for a PROCEEDINGS abstract or paper.
\acmConference[Conference acronym 'XX]{Make sure to enter the correct
  conference title from your rights confirmation email}{June 03--05,
  2018}{Woodstock, NY}
%%
%%  Uncomment \acmBooktitle if the title of the proceedings is different
%%  from ``Proceedings of ...''!
%%
%%\acmBooktitle{Woodstock '18: ACM Symposium on Neural Gaze Detection,
%%  June 03--05, 2018, Woodstock, NY}
\acmISBN{978-1-4503-XXXX-X/2018/06}


%%
%% For managing citations, it is recommended to use bibliography
%% files in BibTeX format.
%%
%% You can then either use BibTeX with the ACM-Reference-Format style,
%% or BibLaTeX with the acmnumeric or acmauthoryear sytles, that include
%% support for advanced citation of software artefact from the
%% biblatex-software package, also separately available on CTAN.
%%
%% Look at the sample-*-biblatex.tex files for templates showcasing
%% the biblatex styles.
%%

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}


\input{agda-generated}
\input{agdamacros}
\input{unicodeletters}

%%
%% end of the preamble, start of the body of the document source.
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{There is Life in the Universes Beyond $\omega$}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Marius Weidner}
\email{weidner@cs.uni-freiburg.de}
\orcid{0009-0008-1152-165X}

\author{Peter Thiemann}
\email{thiemann@acm.org}
\orcid{0000-0002-9000-1239}

\author{Hannes Saffrich}
\email{saffrich@cs.uni-freiburg.de}
\affiliation{%
  \institution{University of Freiburg}
  % \city{Hekla}
  \country{Germany}}
\orcid{0009-0004-7014-754X}


%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
  The first draft of Martin-L\"{o}f's type theory proposed the
  assumption Type:Type. Subsequently, universe levels have been introduced to
  avoid the resulting inconsistencies by assuming
  Type$_i$:Type$_{i+1}$. 
  Proof assistants based on type theory support such universe levels
  to varying degree, but they impose restrictions that can make coding
  awkward.

  Specifically, we consider the ramifications of Agda's
  approach to handling levels using a denotational semantics of a
  stratified version of System F as a motivating example.
  We propose a simple fix that extends Agda's capabilities for handling
  universe levels parametrically up to $\varepsilon_0$.
\end{abstract}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
% \begin{CCSXML}
% \end{CCSXML}

% \ccsdesc[500]{Do Not Use This Code~Generate the Correct Terms for Your Paper}
% \ccsdesc[300]{Do Not Use This Code~Generate the Correct Terms for Your Paper}
% \ccsdesc{Do Not Use This Code~Generate the Correct Terms for Your Paper}
% \ccsdesc[100]{Do Not Use This Code~Generate the Correct Terms for Your Paper}

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{Dependent types, universes, ordinal numbers}


%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

\section{Introduction}
\label{sec:introduction}

The origin of universe levels.

How do universe levels work in Agda?

What becomes awkward with Agda's approach?

How do we propose to fix it?

Contributions.


\section{Preliminaries}
\label{sec:preliminaries}

Agda, Ordinals, IR-Universes


\subsection{Universes in Agda}
\label{sec:universes-agda}

TODO: typeset in Agda style

Agda contains significant support for an infinite  hierarchy of universes \cite{team25:_agda_languag_refer}. It
provides an abstract datatype LEVEL of universe levels along with
constants ZERO, SUC, and MAX that denote the base-level of the
hierarchy, the successor, and the maximum of two levels.
The level-parametric type $Set~i$ stands for the universe at level $i$
and it obeys the typing
SET i : SET (SUC i)
Base types inhabit the universe $Set~zero$.
Type formation handles universe levels in the same way as finitely
stratified System F \cite{DBLP:journals/iandc/Leivant91}. That is,
\begin{itemize}
\item if $A_1 : Set~ i_1$ and $A_2 : Set~i_2$, then $A_1 \to A_2 : Set
  (i_1 \sqcup i_2)$;
\item  if  $\alpha : Set~i$ is a type variable and $A : Set~j$, then
  $\forall \alpha. A : Set (suc~i \sqcup j)$.
\end{itemize}

To avoid inconsistencies, Agda does not allow pattern matching on the
type LEVEL. However, quantification over LEVEL is allowed and results
in a type at level $\omega$ (if the level-typed variable is used in a
significant way). Unfortunately, levels $\omega$ and higher are
\textbf{not} handled in a parametric way in Agda. Rather there are
predefined types $Set_\omega$, $Set_{\omega1}$,
$Set_{\omega2}$, and so on, for the levels $\omega$, $\omega+1$,
$\omega+2$. This design has some limitations, as most 
notions in the standard library (prominently the equality type
and its supporting infrastructure, but also parameteric
types like sums, pairs, lists, and so on) are defined in a level-parametric
way, and thus they cannot be used with SET$_\omega$ 
and higher universe levels.

For convenience, Agda's unification algorithm has special treatment
for the LEVEL datatype and its operators
\cite{team25:_agda_languag_refer}:
\begin{itemize}
\item Idempotence: $a \sqcup a \equiv  a$.
\item 
Associativity: $(a \sqcup b) \sqcup c$ is the same as $a \sqcup (b \sqcup c)$.
\item 
Commutativity: $a \sqcup b$ is the same as $b \sqcup a$.
\item 
Distributivity of SUC over MAX: $suc (a \sqcup b)$ is the same as $suc~ a \sqcup suc~ b$.
\item 
Neutrality of ZERO: $a \sqcup zero$ is the same as $a$.
\item 
Subsumption: $a \sqcup suc~ a$ is the same as $suc~ a$. 
\end{itemize}
In other words, the level structure is a join-semilattice with an
inflationary endomorphism \cite{DBLP:journals/tcs/BezemC22}.

TODO: Cumulativity

\subsection{Ordinals}
\label{sec:ordinals}

Ordinal numbers are an important concept in mathematics and computer
science. They are closely related to well-ordered sets as any
well-ordered set is order-isomorphic to an ordinal. The significance
to computer science is that such well-orders can be used for
termination proofs.

The best known construction of ordinals is a set-theoretic one due to
von Neumann. It starts with the smallest ordinal $0$ represented by
the empty set $\emptyset$. To construct the successor of an ordinal
$\alpha$, we define $\alpha+1  := \alpha \cup \{ \alpha \}$. This way,
we construct $1, 2, 3, \dots$. Then, we can scoop them all up into the
smallest limit ordinal $\omega = \{ 0, 1, 2, 3, \dots \}$, which
contains $0$ and all finite applications of the successor to it. We
continue with $\omega + 1 = \omega \cup \{ \omega \}$ and carry on
until we build the next limit ordinal $\omega \cdot 2$, then $\omega
\cdot 3$, and so on. Constructing the limit at this level yields
$\omega^\omega$ and continuing further leads to
$\omega^{\omega^\omega}$, $\omega^{\omega^{\omega^\omega}}$, and so
on. The limit of this sequence is $\varepsilon_0$ which is the
smallest ordinal that fulfills the equation
$\varepsilon_0 = \omega^{\varepsilon_0}$.

In the context of this paper, we plan to use
ordinals as universe levels where the well-ordering avoids collapsing
levels. The construction of ordinals does not stop at $\varepsilon_0$,
but we wish to carve out a particular set of ordinals that fits
well in an implementation context. Concretely, we consider ordinals
less than $\varepsilon_0$ as they can be represented by binary trees.
To see this, recall that every ordinal $\alpha$ can be written in
Cantor normal form
\begin{align*}
  \alpha &= \omega^{\beta_1} + \omega^{\beta_2}  + \dots + \omega^{\beta_n}
\end{align*}
for some $n\ge0$ and ordinals $\beta_i$ such that
$\beta_1\ge\beta_2\ge \dots \ge \beta_n$. If $\alpha < \varepsilon_0$,
then it can be shown that each exponent satisfies $\beta_i < \alpha$.
If we, again, write $\beta_i = \omega^{\gamma_1} + \dots +
\omega^{\gamma_m}$ in Cantor normal form, then clearly $\gamma_j <
\beta_i < \alpha$. As the ordering on ordinals is a well-order, we
know this decreasing sequence must terminate and we obtain a finite % and normalizing -> representation is unique
representation for each ordinal less than $\varepsilon_0$.

\citet{DBLP:conf/cpp/ForsbergXG20} developed Agda
formalizations for three equivalent representations for precisely this
set of ordinals. They define addition and multiplication of ordinals,
prove the principle of transfinite induction, and use that to prove
that the represented subset of ordinals is well-ordered.

We build on one of their representations, called MutualOrd, define
some additional operations, and prove some properties which are needed
in the context of universe levels.\footnote{Technically, the
  mechanization of \citet{DBLP:conf/cpp/ForsbergXG20} relies on
  cubical Agda \cite{XXX}. We back-ported the definitions for
  MutualOrd to standard Agda, as cubical is not needed for this representation.}
In particular, we prove the laws of a join-semilattice with an
inflationary endomorphism.

TODO: Insert
\begin{itemize}
\item Definition of MutualOrd
\item Explanation
\item Example(s)
\item any additional properties that we had to prove
\end{itemize}

\subsection{Encoding Universes}
\label{sec:encoding-universes}

While Agda has built-in support for universes, it is possible to
``compress'' certain universe hierarchies into
$\ASet$. \citet{DBLP:conf/csl/Kovacs22} constructs a very general model
of cumulative universe hierarchies, which situated entirely in $\ASeti{0}$
and $\ASeti{1}$. The construction requires induction-recursion
\cite{DBLP:conf/tlca/DybjerS99}, so that the model can be constructed
in Agda along with its consistency proof.

Kov\'{a}cs's implementation in Agda is along the lines of
\citet{mcbride15:_datat_datat}'s universe construction. Here we just
recall the most important definitions of his construction of TTDL
(type theory with dependent levels).

A \emph{level structure} provides a set $\ALvl$ of levels, a strict
linear order $<$, evidence that this order is propositional, and a
composition operator that embodies transitivity of the order.

\ULvlStruct

The inductive type $U^{ir}$ of universe codes is defined mutually
recursively with its interpretation $El^{ir}$ in $\ASet$.

\begin{minipage}{0.45\linewidth}
\UUirSpec
\UUir  
\end{minipage}
\begin{minipage}{0.45\linewidth}
\UElirSpec
\UElir
\end{minipage}

The actual universes are defined by induction on the accessibility of
levels.
\UUless
With that we define the semantic hierarchy and its decoding function.

\begin{minipage}{0.45\linewidth}
  \UU
\end{minipage}
\begin{minipage}{0.45\linewidth}
  \UEl
\end{minipage}

To fit in with the way that stratified System~F (as well as Agda)
handles levels, we need a non-strict lift operator on universes and
proof that lifting does not change the semantic representation.

\begin{minipage}{0.45\linewidth}
  \ULiftLe
\end{minipage}
\begin{minipage}{0.45\linewidth}
  \UElLiftLe
\end{minipage}

With these operators, Kov\'{a}cs defines an alternative $\Pi$-type encoding that fits perfectly
with the requirements of stratified System~F.
\UAltPi

Here, $\sqcup_1$ and $\sqcup_2$ are proofs that the first (second)
argument of $\sqcup$ is less than or equal to their maximum. The
function {\Acoe} transforms a type by applying an equality to it.

\citet{DBLP:conf/csl/Kovacs22} also provides a worked example of a
level structure for ordinals up to $\omega+\omega$, corresponding to
the current version of Agda, as well as some infrastructure for
using type-theoretic ordinals as levels.

\section{Running Example}
\label{sec:running-example}

As a running example for demonstrating various encodings, we consider
different extensions of finitely stratified System F
\cite{DBLP:journals/iandc/Leivant91}. More precisely, we start from an
intrinsically typed encoding of types and expressions, then we
construct denotational semantics for different encodings and discuss
their respective merits.

We choose this system as it is significant, presents non-trivial
challenges, and it has been studied in the literature. Our encoding of
syntax is inspired by \citet{DBLP:conf/mpc/ChapmanKNW19}, who develop
the syntactic metatheory of System-F$\omega$ (without
stratification). It has been  picked up by
\citet{DBLP:conf/tyde/Saffrich0W24}, who give denotational and operational semantics
for finitely stratified System-F and develop a logical relation for
it. \citet{DBLP:journals/pacmpl/HubersM23} use a similar syntax
representation for a finitely stratified version of System-F$\omega$
extended with qualified types. They also develop a denotational
semantics for their calculus. All these papers come with Agda
formalizations. 

The following subsections gives some excerpts from our Agda
formalization which is available as supplemental material. We
generally omit definitions for renamings and substitutions in the
paper as they closely follow the abovementioned references. While the
definitions are available in the supplemental material, some
scaffolding lemmas (e.g., about composition of substitutions) are only
postulated as their proofs can either be found in the abovementioned
references or their proofs are very similar to proofs found there. 

\subsection{Types}
\label{sec:syntax-types}

We start with an intrinsically-typed encoding of types and expressions
of finitely stratified System~F. Like
\citet{DBLP:conf/tyde/Saffrich0W24} and
\citet{DBLP:journals/pacmpl/HubersM23}, we rely on Agda's $\ALevel$
type to represent levels syntactically. This choice has the advantage
that Agda's special treatment applies to syntactic levels (see
\ref{sec:universes-agda}). The representation of a type variable
context is thus.
\SFTEnv
Types take a type variable context as a parameter and a level
index. The variables $\ell$, $\ell_1$, \dots{} range over
$\ALevel$. The construction is standard. Base types live at level
$\Azero$; function types live at the maximum level of argument and
return types; type variables are
represented by their position in the type variable context, i.e.,
as de Bruijn indices; and
universal quantification introduces a new type variable at level $\ell$.
\SFType
Variable contexts are indexed by a type variable context. They
are either empty, bind a variable to a type, or bind a type variable
to a level. Correspondingly, variable access $\_\ni\_$ has two ways to
skip over a binding. Accessing a variable across a type variable
binding (in \Atskip) requires weakening the type found before the type
binding.\footnote{{\ATwk} is a standard renaming on types that
  performs weakening.}

\begin{minipage}{0.45\linewidth}
  \SFEEnv
\end{minipage}
\begin{minipage}{0.45\linewidth}
  \SFEEnvNi
\end{minipage}

\subsection{Expressions}
\label{sec:syntax-expressions}


Expressions take a variable context as a parameter and are indexed
by a type, as usual. The first five cases are standard as for
simply-typed lambda calculus. The type-lambda takes the level of the
new type variable and a body expression that is typed in a
level-extended variable context to construct an expression of type
$\forall\alpha T$. Type application takes such an expression and a
type of suitable level to construct an expression of type $T[T']$,
that is, substituting the first variable in $T$ by $T'$.

\SFExpr

\section{Native Agda Semantics}
\label{sec:semantics}

Each denotational semantics consists of two parts: the semantics of
types and the semantics of expressions.

The native semantics maps a type at level
$\ell$ to $\ASeti\ell$. Due to the presence of type variables, the
semantics needs a type variable environment that maps a type variable
to its denotation. There are several options in defining this
environment.

\begin{enumerate}
\item We may define it as a function as follows:
  \SFFTSEOmega
  This definition lives in Agda's (fixed) $\ASeto$, so
  that equational reasoning at the type becomes inconvenient.
\item We may also define it as an inductive datatype
  \SFFTSEInductive
  Again, this definition lives in $\ASeto$, although we might think of
  defining a function that computes the level of the environment from
  the type variable context:
  \SFTEnvLub
  However, Agda does not let us to define an inductive datatype where
  the level depends on an index type.
\item Finally, we define it as a function by induction:
  \SFFTSEAsFunction
\end{enumerate}
We adopt the last alternative to define the type semantics:
A type at level $\ell$ is interpreted as an element of $\ASeti\ell$.
\SFTypeSem

The key to make this semantics readable lies in our choice of the
$\ALevel$ datatype for syntactic levels. If we chose other
numbers, e.g., natural numbers, for syntactic levels, the definitions
for function types and universal types would become cluttered with
transport lemmas (see \ref{xxx-example-transport}).

For the expression semantics, we also need a variable environment.
We define it analogously to the type variable environment, with a
function to compute the maximum level in the environment and another
to build the environment structure. The latter is not surprising:
nested pairs of values.

\begin{minipage}{0.45\linewidth}
  \SFEEnvLub
\end{minipage}
\begin{minipage}{0.45\linewidth}
  \SFFESEAsFunction
\end{minipage}

The first five cases of the expression semantics correspond again to
the analogous construction for the simply-typed lambda calculus. The
interpretation of a type-lambda at level $\ell$ is a function that
takes an element $A : \ASeti\ell$ and stores it in the type variable
environment. The interpretation of a type application is essentially
the interpretation of its underlying expression $e$, but the type has
to be adjusted according to the type substitution. The type of the
required equality $\Aeq$ shows that we trade the type interpretation
of $T'$ in the type variable environment for the substitution of $T'$
into $T$. The lemmas involved are straightforward substitution
lemmas. 

\SFESem

To wrap up, the construction of a native Agda semantics for stratified
System~F is not too hard. One crucial point is choosing a good
definition for the type variable environment. Because we chose a
definition that does \emph{not} require $\ASeto$, all equalities (in
particular $\Aeq$ in the interpretation of type application) live in a
suitable level-indexed universe and can be handled homogeneously by
library definitions.

The transport equality $\Aeq$ appears to be unavoidable. So is another
equality (not shown) in the definition of $lookup-\gamma$.

The interpretation of types requires no transports because of Agda's
special treatment for the normalization and unification of the
$\ALevel$ type.

\section{Level Quantification}
\label{sec:level-quantification}

As a new twist, we add level quantification (as in Agda) to the source
language. To this end, we need a new syntactic category: level
expressions. They take a level variable context {\IRLEnv} (ranged over
by $\delta$) as a parameter and are
indexed by a $\AMode$, ranged over by $\mu$. The former determines the
level variables that may appear and the latter determines whether a level
expression denotes a finite level, less than $\omega$, ($\Afin$) or if
it is unrestricted ($\Aany$).

\IRLvl

From the indices we can see that level variables range over finite
levels, the successor and maximum operators can be used with finite
and unrestricted levels, and any expression containing $\omega$ is not
finite. From the structure of level expressions, we can see that all
denoted levels must be smaller than $\omega + \omega$. 

Consequently, there are two interpretations of level expressions, a
finite one and a general one. We map finite expressions to natural
numbers and general expressions to pairs of natural numbers $(i, j)$
representing the ordinal $\omega\cdot i + j$. 
Both are relative to an interpretation of the level variables as
finite levels, that is, natural numbers.

\IRLEnvSem

\begin{minipage}{0.45\linewidth}
  \IRLSemFin
\end{minipage}
\begin{minipage}{0.45\linewidth}
  \IRLSemAny
\end{minipage}


\begin{minipage}{0.45\linewidth}
  \IRTEnv
\end{minipage}
\begin{minipage}{0.45\linewidth}
  \IRTEnvNi
\end{minipage}

\IRType

\IRFTSEAsFunction

\IRencode

\IRTSem

\begin{minipage}{0.45\linewidth}
  \IREEnv
\end{minipage}
\begin{minipage}{0.45\linewidth}
  \IREEnvNi
\end{minipage}

\IRExpr

\IRTEnvSem

\IRESem



While the semantics of level quantification can be expressed
``natively'' within Agda, it is cumbersome and not fully general.
For that reason, we turn to a semantics using an inductive-recursively
defined universe. More precisely, we instantiate Kov\'acs's
construction suitably.

\section{Related Work}
\label{sec:related-work}

How do other proof assistants (Coq, Lean) handle universes?
Cumulativity, Impact of impredicativity


\section{Conclusions}
\label{sec:conclusions}


%%
%% The acknowledgments section is defined using the "acks" environment
%% (and NOT an unnumbered section). This ensures the proper
%% identification of the section in the article metadata, and the
%% consistent spelling of the heading.
\begin{acks}
  To whom it may concern.
\end{acks}

%%
%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{ACM-Reference-Format}
\bibliography{references}


\end{document}
\endinput
